(self["webpackChunkgl_starter"]=self["webpackChunkgl_starter"]||[]).push([[1236],{69115:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\n\nuniform vec2 uCoord;\nvarying vec2 vUv;\nuniform float uTime;\nuniform float uLoopAlpha;\n\nuniform sampler2D uNoiseTex;\nuniform sampler2D uTex1;\nuniform bool uShaking1;\nuniform sampler2D uTex2;\nuniform bool uShaking2;\nuniform sampler2D uTex3;\nuniform bool uShaking3;\nuniform sampler2D uTex4;\nuniform bool uShaking4;\n\nfloat greyscale(vec3 col) {\n  float grey = dot(col, vec3(0.299, 0.587, 0.114));\n  return grey;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvoid main(void) {\n  vec2 uv = vec2(vUv.x, vUv.y);\n  // uv += vec2(0.5);\n  // uv *= .5;\n\n  // parallax effect\n  float parallaxZone = distance(0.5, uv.y) + distance(0.5, uv.x);\n  parallaxZone = smoothstep(0.2, 0.7, parallaxZone);\n  parallaxZone *= 1.5;\n  vec2 uvParallax = (uCoord * -1.) * (0.03 + (0.01 * parallaxZone));\n\n  // jitter animation\n  vec4 noise = texture2D(uNoiseTex, uv * 1. + vec2(floor(uTime * 5.) * .1));\n  vec2 shakeUV = uv + (noise.r - 0.5) * 0.0025;\n\n  vec2 uv1 = mix(uv, shakeUV, step(0.5, float(uShaking1))) + uvParallax * 0.23;\n  vec2 uv2 = mix(uv, shakeUV, step(0.5, float(uShaking2))) + uvParallax * 0.;\n  vec2 uv3 = mix(uv, shakeUV, step(0.5, float(uShaking3))) + uvParallax * 0.5;\n  vec2 uv4 = mix(uv, shakeUV, step(0.5, float(uShaking4))) + uvParallax * 1.;\n\n  vec4 tex1 = texture2D(uTex1, uv1);\n  vec4 tex2 = texture2D(uTex2, uv2);\n  vec4 tex3 = texture2D(uTex3, uv3);\n  vec4 tex4 = texture2D(uTex4, uv4);\n\n  // vec4 bg = vec4(234. / 255., 228. / 255., 203. / 255., 1.);\n  vec4 bg = vec4(239. / 255., 234. / 255., 218. / 255., 1.);\n\n  vec4 col = tex1;\n  \n  // With animal visible behind texture blended  \n  // vec4 loopTex = tex2;\n  // loopTex = mix(col, loopTex, smoothstep(0., 0.7, tex2.a * uLoopAlpha));\n  // col = loopTex;\n  // vec4 blendBase = vec4(mix(col.rgb, bg.rgb, 1. - col.a), 1.);\n  // vec3 tex3c = blendMultiply(blendBase.rgb, tex3.rgb, tex3.a);\n  // col = vec4(tex3c, col.a + tex3.a);\n  // -----\n  // With animal almost not visible behind texture blended  \n  vec4 blendBase = vec4(mix(col.rgb, bg.rgb, 1. - col.a), 1.);\n  vec3 tex3c = blendMultiply(blendBase.rgb, tex3.rgb, tex3.a);\n  col = vec4(tex3c, col.a + tex3.a);\n  vec4 loopTex = tex2;\n  loopTex = mix(loopTex, col, tex3.a * 0.96);\n  loopTex = mix(col, loopTex, smoothstep(0., 0.7, tex2.a * uLoopAlpha));\n  col = loopTex;\n  // -----\n\n  vec3 tex4c = mix(col.rgb, tex4.rgb, tex4.a);\n  col.rgb = tex4c;\n  col.a = max(col.a, tex4.a);\n\n\n  // col.r += parallaxZone * 0.3;\n  //col = vec4(tex4.a,tex4.a,tex4.a,1.); \n  gl_FragColor = col;\n}\n",o};o.toString=o,n.exports=o,o.onHmr=function(){}},85164:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute vec2 aTexCoord;\n\nvarying vec2 vUv;\n\n\nvoid main(void){\n  vec4 pos = vec4(aPosition, 1.0);\n\n  gl_Position = pos;\n  vUv = aTexCoord;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},54895:function(n){var o=function(n){var o="";return o+="precision highp float;\nvarying vec2 vUv;\nuniform sampler2D uCurrentTex;\nuniform sampler2D uNextTex;\nuniform sampler2D uWNoiseTex;\nuniform float uSaturation;\nuniform vec2 uRez;\n\nfloat greyscale(vec3 col){\n  float grey = dot(col, vec3(0.299, 0.587, 0.114));\n  return grey;\n}\n\nvec3 czm_saturation(vec3 rgb, float adjustment)\n{\n    // Algorithm from Chapter 16 of OpenGL Shading Language\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n    return mix(\n        sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend),\n        2.0 * base * blend + base * base * (1.0 - 2.0 * blend),\n        step(base, vec3(0.5))\n    );\n}\n\nvoid main() {\n    vec2 uv = vec2(vUv.x, vUv.y);\n    vec4 t1 = texture2D(uCurrentTex, uv);\n    vec4 t2 = texture2D(uNextTex, uv);\n\n    vec4 mixedTextures = mix(t1, t2, smoothstep(0., 0.7, t2.a));\n    vec4 c = mixedTextures;\n\n    // --- GRAIN ---\n    float aspect = uRez.x / uRez.y;\n    float grain = texture2D(uWNoiseTex, vec2(vUv.x * aspect, vUv.y) * 3.).r;\n    vec3 noiseCol = blendSoftLight(c.rgb, vec3(grain));\n    c.rgb = mix(c.rgb, noiseCol, 0.65);\n    // ---\n\n    c.rgb = czm_saturation(c.rgb, uSaturation);\n    gl_FragColor = c;\n    gl_FragColor = vec4(c.rgb, 1.0);\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},10466:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute vec2 aTexCoord;\n\nvarying vec2 vUv;\n\nuniform mat4 uMVP;\n\nvoid main(void){\nvec4 pos = vec4(aPosition, 1.0);\n\ngl_Position = uMVP * pos;\nvUv = aTexCoord;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},23131:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\n\nuniform vec4 uTopColor;\nuniform vec4 uMiddleColor;\nuniform vec4 uBottomColor;\n\nuniform int uType;\nuniform float uRadialStrength;\n\nvarying vec2 vUv;\n\nconst float NOISE_GRANULARITY = 0.5/255.0;\n\nfloat random(vec2 coords) {\n  return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main(void){\n  vec3 color;\n\n  if (uType == 0) {\n    \n    float distToCenter = distance(vUv, vec2(0.5));\n    distToCenter *= uRadialStrength * 2.;\n    distToCenter = max(0., min(1., distToCenter));\n    color = mix(uBottomColor.rgb, uTopColor.rgb, distToCenter);\n\n  } else if (uType == 1) {\n\n    color = mix(uBottomColor.rgb, uTopColor.rgb, vUv.y);\n\n  } else {\n\n    color = mix(uBottomColor.rgb, uMiddleColor.rgb, (vUv.y - uBottomColor.a) / (uMiddleColor.a - uBottomColor.a));\n    color = mix(color, vec3(0.), step(uMiddleColor.a, vUv.y));\n\n    vec3 colorB = mix(uMiddleColor.rgb, uTopColor.rgb, (vUv.y - uMiddleColor.a) / (uTopColor.a - uMiddleColor.a));\n    colorB = mix(colorB, vec3(0.), step(vUv.y, uMiddleColor.a));\n\n    color += colorB;\n\n  }\n\n  vec3 ditheredColor = color + mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(vUv));\n\n  gl_FragColor = vec4(ditheredColor, 1.);\n}\n",o};o.toString=o,n.exports=o,o.onHmr=function(){}},28546:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute vec2 aTexCoord;\n\nvarying vec2 vUv;\n\nuniform mat4 uMVP;\n\nvoid main(void){\n  vec4 pos = vec4(aPosition, 1.0);\n\n  gl_Position = uMVP * pos;\n  vUv = aTexCoord;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},8811:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\n\nvarying vec2 vTexCoord0;\nuniform sampler2D tTex;\n\nvoid main(void){\n  gl_FragColor = texture2D( tTex, vTexCoord0 );\n}\n",o};o.toString=o,n.exports=o,o.onHmr=function(){}},30610:function(n){var o=function(n){var o="";return o+="attribute vec2 aPosition;\nattribute vec2 aTexCoord;\n\nvarying vec2 vTexCoord0;\n\n  \nvoid main( void ){\n  gl_Position = vec4( aPosition, 0.0, 1.0 );\n  vTexCoord0 = aTexCoord;\n}\n",o};o.toString=o,n.exports=o,o.onHmr=function(){}},29491:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\n\n#define PI 3.1415926535897932384626433832795\n\nuniform sampler2D uTex;\nuniform sampler2D uNoise;\nuniform sampler2D uBrush1;\nuniform float uNoiseStep;\nuniform float uAccumulation;\nuniform float uAlpha;\nuniform float uAngle;\nuniform float uScale;\nuniform float uRandAngle;\nuniform float uRandAngleInfluence;\nuniform bool uRandAngleEnabled;\n// uniform vec3 uRand;\n\nuniform float uAspect;\nuniform vec2 uCoord;\nuniform vec2 uVelocity;\nuniform vec3 uChanToUse;\n\nvarying vec2 vUv;\n\nfloat sat( float t ) {\n  return clamp( t, 0.0, 1.0 );\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec2 rotate(vec2 v, float angle) {\n    return rotate2d(angle) * vec2(v.x * uAspect, v.y);\n    // return rotate2d(angle) * vec2(v.x, v.y);\n}\n\nfloat greyscale(vec3 col){\n  float grey = dot(col, vec3(0.299, 0.587, 0.114));\n  return grey;\n}\n\n\nvec4 blur5(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.3333333333333333) * direction;\n  color += texture2D(image, uv) * 0.29411764705882354;\n  color += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;\n  color += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;\n  return color; \n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n  float FALLOF_MIN_S = 0.125;\n\n  vec4 color = texture2D(uTex, vUv);\n\n  float vecMagn = length(uVelocity);\n  vecMagn /= 4.;\n  vecMagn = sat(vecMagn);\n  // vecMagn = max(0.5, abs(uVelocity.x + uVelocity.y) / 10.);\n\n  vec2 coord = ((vec2(uCoord) + vec2(1.)) / 2.);\n\n  vec2 noiseUv = vUv;\n  noiseUv += 0.5;\n  noiseUv *= rotate2d(uAngle + PI / 2.);\n  noiseUv -= 0.5;\n\n  float noise = blur5(uNoise, noiseUv / vec2(1., 10.) * 1., vec2(1.), vec2(1., -1.)).r;\n\n  vec2 brushUv = vUv;\n  float scaleFactor = uScale;\n  brushUv *= scaleFactor;\n  brushUv -= (coord * scaleFactor);\n  brushUv /= scaleFactor;\n  brushUv = rotate(brushUv, (uRandAngleEnabled ? uRandAngle * uRandAngleInfluence : uAngle + PI / 2.));\n  brushUv *= scaleFactor;\n  \n  float brushT = texture2D(uBrush1, brushUv + vec2(0.5)).a;\n\n  vec2 curshShapeDeformation = vec2(.5, .8);\n  float cursor = smoothstep(0.3, 0.0, length(brushUv * curshShapeDeformation));\n\n  float noiseEdges = brushT * cursor;\n  noiseEdges = smoothstep(0., 1. - 0.2 * vecMagn, 1. - noiseEdges);\n  noiseEdges *= noise;\n  // noiseEdges = mix(noiseEdges + cursor, noiseEdges, vecMagn);\n\n  float finalC = mix(brushT, sat(brushT - 1.), step(uNoiseStep, noiseEdges));\n  // color.rgb = mix(color.rgb, color.rgb + vec3(1.) * (finalC - (0.3 * noise * finalC)), color.a);\n  float oldColorZone = greyscale(color.rgb);\n  color.rgb = mix(color.rgb + (finalC * uAccumulation) * uAlpha * uChanToUse, color.rgb * uChanToUse, oldColorZone * uChanToUse);\n  // color.rgb = vec3(pow(sat(vecMagn), 1.));\n  color.a = 1.;\n  gl_FragColor = color;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},1587:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute vec2 aTexCoord;\n\nvarying vec2 vUv;\n\n\nvoid main(void){\n  vec4 pos = vec4(aPosition, 1.0);\n\n  gl_Position = pos;\n  vUv = aTexCoord;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},39483:function(n){var o=function(n){var o="";return o+="precision highp float;\nvarying vec2 vUv;\nuniform sampler2D uTex;\nuniform sampler2D uWNoise;\nuniform float uGrainVisibility;\nuniform float uAspect;\nuniform vec3 uColor;\nuniform float uBackgroundAlpha;\nuniform float uBrushAlpha;\n\nuniform vec3 uColorIntro1;\nuniform vec3 uColorIntro2;\nuniform bool uIsIntro;\n\nfloat blendSoftLight(float base, float blend) {\n  return (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n  return vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n  return (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat greyscale(vec3 col){\n  float grey = dot(col, vec3(0.299, 0.587, 0.114));\n  return grey;\n}\n\nvoid main() {\n  vec3 c = uColor;\n\n  vec4 tex = texture2D(uTex, vUv);\n  vec4 color = vec4(1., 1., 1., 0.);  \n  if(uIsIntro) {\n    color = mix(color, vec4(uColorIntro1, tex.a), tex.r);  \n    color = mix(color, vec4(uColorIntro2, tex.a), tex.g);\n  } else {\n    color = mix(vec4(1., 1., 1., 0.), vec4(c, tex.a), tex.r);\n  }\n\n  float grain = texture2D(uWNoise, vec2(vUv.x * uAspect, vUv.y) * 3.).r;\n  vec3 noiseCol = blendSoftLight(color.rgb, vec3(grain));\n  color.rgb = mix(color.rgb, noiseCol, uGrainVisibility);\n\n  color.a *= uBrushAlpha;\n\n  vec4 bgColor = vec4(234. / 255., 228. / 255., 203. / 255., uBackgroundAlpha);\n  vec4 mixColor = mix(vec4(c.rgb, 0.), bgColor, float(uIsIntro));\n  vec4 finalColor = mix(mixColor, color, color.a);\n\n  if(!uIsIntro) {\n    finalColor.a -= smoothstep(0.4, 0.7, grain) * .15;\n  }\n  gl_FragColor = finalColor;\n  // gl_FragColor = vec4(smoothstep(0.2, 0.8, finalColor.a));\n  // gl_FragColor = vec4(vec3(finalColor.a), 1.0);\n  // gl_FragColor = tex;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},33431:function(n){var o=function(n){var o="";return o+="precision highp float;\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vUv;\nvoid main() {\n  gl_Position = vec4(aPosition, 1.0);\n  vUv = aTexCoord;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},70071:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\n\nuniform vec3 uColor;\nuniform float uTime;\nuniform float uMinX;\nuniform float uMaxX;\n\nvarying vec3 vWorldPos;\nvarying vec3 vLocalPos;\nvarying float vOpacity;\n\nvoid main(void){\n  float alpha = distance(gl_PointCoord, vec2(0.5, 0.5));\n  float limits = smoothstep(uMinX + 5., uMinX + 15., vLocalPos.x) * smoothstep(uMaxX - 5., uMaxX - 15., vLocalPos.x);\n  gl_FragColor = vec4(uColor, step(alpha, 0.5) * limits * vOpacity);\n}\n",o};o.toString=o,n.exports=o,o.onHmr=function(){}},25806:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute float aSettings;\n\nuniform float uTime;\nuniform float uOffset;\nuniform float uMaxSize;\nuniform float uMinX;\nuniform float uMaxX;\nuniform float uScaleSubtract;\nuniform mat4 uVP;\nuniform mat4 uWorldMatrix;\n\nvarying vec3 vWorldPos;\nvarying vec3 vLocalPos;\nvarying float vOpacity;\n\nvoid main(void) {\n  vec3 localPos = aPosition;\n  localPos.x = uMinX + mod(-uTime + localPos.x, uMaxX - uMinX);\n  vec4 pos = uWorldMatrix * vec4(localPos, 1.0);\n\n  gl_Position = uVP * pos;\n  gl_PointSize = uMaxSize / gl_Position.w;\n\n  vWorldPos = pos.xyz;\n  vLocalPos = localPos.xyz;\n\n  vOpacity = aSettings;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},45695:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\nuniform sampler2D uColorTex;\nuniform sampler2D uNoise;\nuniform sampler2D uSprite;\nuniform float uAspect;\nuniform float uSphereBgProgress;\nuniform float uTopGradient;\nuniform float uBottomGradient;\nvarying vec2 vUv;\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n  return mix(\n    sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend),\n    2.0 * base * blend + base * base * (1.0 - 2.0 * blend),\n    step(base, vec3(0.5))\n  );\n}\n\nfloat sat(float value) {\n  return clamp(value, 0.0, 1.0);\n}\n\nvoid main(void){\n  float toSphereBgProgress = uSphereBgProgress;\n\n  vec3 beigeColor = vec3(0.9176470588, 0.8941176471, 0.7960784314);\n  vec3 blueColor = vec3(0. / 255., 40. / 255., 77. / 255.);\n  // vec3 blueColor = vec3(255. / 255., 0. / 255., 0. / 255.);\n  vec3 baseColor = blueColor;\n  vec3 colorTex = texture2D(uColorTex, vUv).rgb;\n\n  float topGradient = mix(1., sat((1. - vUv.y) * (2.5 - uTopGradient * .5)), uTopGradient);\n  float botGradient = mix(1., sat(vUv.y * (2.5 - uBottomGradient * .5)), uBottomGradient);\n\n  // float vignetteMin = 0.05;\n  // float vignetteMin = 0.3;\n  // float vignetteMax = 0.3;\n  // float vignetteMax = 0.5;\n  // float vignette =  smoothstep(vignetteMin, vignetteMax, vUv.y) * smoothstep(vignetteMin, vignetteMax, 1. - vUv.y);\n\n  vec3 finalColor = mix(baseColor, colorTex, toSphereBgProgress);\n  finalColor = mix(finalColor * 0.5, finalColor, botGradient);\n  finalColor = mix(finalColor * 0.5, finalColor, topGradient);\n  gl_FragColor = vec4(finalColor, 1.0);\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},89606:function(n){var o=function(n){var o="";return o+="attribute vec2 aPosition;\nattribute vec2 aTexCoord;\n\nvarying vec2 vUv;\n\nvoid main(void){\n  gl_Position = vec4(aPosition, 0.0, 1.0);\n  vUv = aTexCoord;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},5229:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\nvarying vec2 vUv;\nuniform sampler2D uDiffuse;\nuniform float uAlpha;\nuniform float uTime;\nuniform float uNoiseToRight;\nuniform sampler2D uNoise;\n\n\nvoid main() {\n  vec3 noise = texture2D(uNoise, vUv * 1. + uTime * 0.00002).rgb;\n\n  vec4 color = texture2D(uDiffuse, vUv + (noise.rg * 0.15 * uNoiseToRight));\n  float fadeZone = smoothstep(0., 0.1, vUv.x) * smoothstep(1., 0.9, vUv.x) * smoothstep(0., 0.2, vUv.y) * smoothstep(1., 0.8, vUv.y);\n\n  color.a *= uAlpha * 1.;\n  color.a *= fadeZone;\n  color.a *= 1.2;\n\n  gl_FragColor = color;\n  // gl_FragColor.rgb = vec3(fadeZone);\n  // gl_FragColor.a = 1.;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},97062:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute vec2 aTexCoord;\n\nvarying vec2 vUv;\nuniform mat4 uMVP;\n\nvoid main(void) {\n  vec4 pos = vec4(aPosition, 1.0);\n\n  gl_Position = uMVP * pos;\n  vUv = aTexCoord;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},97911:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\n#define PI 3.1415926535897932384626433832795\n#define PI2 6.2831853072\nvarying vec2 vUv;\nuniform float uTime;\n// uniform vec2 uRes;\n// uniform float uAspect;\n// uniform sampler2D tBackground;\nuniform sampler2D uDotTex;\n// uniform sampler2D uNoiseTex;\n// uniform sampler2D uSpriteTex;\nuniform vec2 uSpriteMaxColRow;\nuniform vec2 uSpriteCurrColRow;\nuniform vec2 uSpriteCellSize;\n// uniform float uDotSize;\nuniform float uAlpha;\nuniform sampler2D uWNoiseTex;\n\nvec3 czm_saturation(vec3 rgb, float adjustment) {\n  const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n  vec3 intensity = vec3(dot(rgb, W));\n  return mix(intensity, rgb, adjustment);\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n  return mix(\n    sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend),\n    2.0 * base * blend + base * base * (1.0 - 2.0 * blend),\n    step(base, vec3(0.5))\n  );\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\nvoid main() {\n  // Mask sprite texture\n  vec2 cellSize = uSpriteCellSize;\n  vec2 spriteUv = vUv;\n  spriteUv.y = spriteUv.y / uSpriteMaxColRow.y;\n  spriteUv.x = spriteUv.x / uSpriteMaxColRow.x;\n  spriteUv.y -= cellSize.y;\n\n  float col = uSpriteCurrColRow.x;\n  float row = uSpriteCurrColRow.y;\n  spriteUv.x += col * cellSize.x;\n  spriteUv.y -= row * cellSize.y;\n\n  // float mask = texture2D(uSpriteTex, spriteUv).a;\n\n  // Jitter effect using noise texture\n  // vec4 noiseJitter = texture2D(uNoiseTex, vUv + vec2(floor(uTime * 0.07) * .1));\n  // vec2 shakeUV = vUv + (noiseJitter.rg - 0.5) * 0.03;\n\n  vec4 bgColor = vec4(234. / 255., 228. / 255., 203. / 255., 0.);\n\n  // Sample the background texture with jitter effect\n  vec4 textureColorBase = texture2D(uDotTex, spriteUv);\n  vec4 textureColor = textureColorBase;\n\n\n  // Mix the background and texture color based on texture alpha\n  // vec4 finalColor = mix(bgColor, textureColor, textureColor.a * mask);\n  vec4 finalColor = mix(bgColor, textureColor, textureColor.a);\n\n  // float grain = texture2D(uWNoiseTex, shakeUV * 3.0).r;\n  float grain = texture2D(uWNoiseTex, vUv * 3.0).r;\n  vec3 noiseCol = blendSoftLight(finalColor.rgb, vec3(grain));\n  finalColor.rgb = mix(finalColor.rgb, noiseCol, 0.65);\n  finalColor.a *= uAlpha;\n  gl_FragColor = vec4(finalColor);\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},51981:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute vec2 aTexCoord;\n\nvarying vec2 vUv;\nuniform mat4 uMVP;\n\nvoid main(void) {\n  vec4 pos = vec4(aPosition, 1.0);\n\n  gl_Position = uMVP * pos;\n  vUv = aTexCoord;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},16802:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\n#define PI 3.1415926535897932384626433832795\n#define PI2 6.2831853072\nvarying vec2 vUv;\nuniform float uTime;\nuniform sampler2D uDotTex;\nuniform vec2 uSpriteMaxColRow;\nuniform vec2 uSpriteCurrColRow;\nuniform vec2 uSpriteCellSize;\nuniform float uAlpha;\nuniform sampler2D uWNoiseTex;\nuniform sampler2D uNoiseTex;\n\nvec3 czm_saturation(vec3 rgb, float adjustment) {\n  const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n  vec3 intensity = vec3(dot(rgb, W));\n  return mix(intensity, rgb, adjustment);\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n  return mix(\n    sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend),\n    2.0 * base * blend + base * base * (1.0 - 2.0 * blend),\n    step(base, vec3(0.5))\n  );\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\nvoid main() {\n  // Mask sprite texture\n  vec2 cellSize = uSpriteCellSize;\n  vec2 spriteUv = vUv;\n  spriteUv.y = spriteUv.y / uSpriteMaxColRow.y;\n  spriteUv.x = spriteUv.x / uSpriteMaxColRow.x;\n  spriteUv.y -= cellSize.y;\n\n  float col = uSpriteCurrColRow.x;\n  float row = uSpriteCurrColRow.y;\n  spriteUv.x += col * cellSize.x;\n  spriteUv.y -= row * cellSize.y;\n\n  // float mask = texture2D(uSpriteTex, spriteUv).a;\n\n  // Jitter effect using noise texture\n  vec4 noiseJitter = texture2D(uNoiseTex, vUv + vec2(floor(uTime * 5.) * 0.2));\n  spriteUv += noiseJitter.xy * 0.01 - 0.005;\n\n  vec4 bgColor = vec4(234. / 255., 228. / 255., 203. / 255., 0.);\n\n  // Sample the background texture with jitter effect\n  vec4 textureColorBase = texture2D(uDotTex, spriteUv);\n  vec4 textureColor = textureColorBase;\n\n\n  // Mix the background and texture color based on texture alpha\n  // vec4 finalColor = mix(bgColor, textureColor, textureColor.a * mask);\n  vec4 finalColor = mix(bgColor, textureColor, textureColor.a);\n\n  // float grain = texture2D(uWNoiseTex, shakeUV * 3.0).r;\n  float grain = texture2D(uWNoiseTex, vUv * 3.0).r;\n  vec3 noiseCol = blendSoftLight(finalColor.rgb, vec3(grain));\n  finalColor.rgb = mix(finalColor.rgb, noiseCol, 0.65);\n  finalColor.a *= uAlpha;\n  gl_FragColor = vec4(finalColor);\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},78755:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute vec2 aTexCoord;\n\nvarying vec2 vUv;\nuniform mat4 uMVP;\n\nvoid main(void) {\n  vec4 pos = vec4(aPosition, 1.0);\n\n  gl_Position = uMVP * pos;\n  vUv = aTexCoord;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},34779:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\nuniform sampler2D uColorTex;\nuniform sampler2D uNoise;\nuniform sampler2D uSprite;\nuniform float uAspect;\nuniform float uSphereBgProgress;\nuniform float uTopGradient;\nuniform float uBottomGradient;\nvarying vec2 vUv;\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n  return mix(\n    sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend),\n    2.0 * base * blend + base * base * (1.0 - 2.0 * blend),\n    step(base, vec3(0.5))\n  );\n}\n\nfloat sat(float value) {\n  return clamp(value, 0.0, 1.0);\n}\n\nvoid main(void){\n  float toSphereBgProgress = uSphereBgProgress;\n\n  vec3 beigeColor = vec3(0.9176470588, 0.8941176471, 0.7960784314);\n  vec3 blueColor = vec3(0. / 255., 40. / 255., 77. / 255.);\n  vec3 baseColor = blueColor;\n  vec3 colorTex = texture2D(uColorTex, vUv).rgb;\n\n  float topGradient = mix(1., sat((1. - vUv.y) * (2.5 - uTopGradient * .5)), uTopGradient);\n  float botGradient = mix(1., sat(vUv.y * (2.5 - uBottomGradient * .5)), uBottomGradient);\n\n  // float vignetteMin = 0.05;\n  // float vignetteMin = 0.3;\n  // float vignetteMax = 0.3;\n  // float vignetteMax = 0.5;\n  // float vignette =  smoothstep(vignetteMin, vignetteMax, vUv.y) * smoothstep(vignetteMin, vignetteMax, 1. - vUv.y);\n\n  vec3 finalColor = mix(baseColor, colorTex, toSphereBgProgress);\n  finalColor = mix(finalColor * 0.5, finalColor, botGradient);\n  finalColor = mix(finalColor * 0.5, finalColor, topGradient);\n  gl_FragColor = vec4(finalColor, 1.0);\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},99435:function(n){var o=function(n){var o="";return o+="attribute vec2 aPosition;\nattribute vec2 aTexCoord;\n\nvarying vec2 vUv;\n\nvoid main(void){\n  gl_Position = vec4(aPosition, 0.0, 1.0);\n  vUv = aTexCoord;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},41830:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\nvarying vec2 vUv;\nuniform sampler2D uDiffuse;\nuniform float uAlpha;\nuniform float uAlphaDist;\nuniform float uTime;\nuniform float uIsTlClouds;\nuniform float uFirstRow;\nuniform sampler2D uNoise;\n\nvarying float vDepth;\n\nvoid main() {\n  vec3 noise2 = texture2D(uNoise, vUv * vec2(.1, .1) + vec2(uTime * 0.00005, 0.)).rgb;\n  vec3 noise = texture2D(uNoise, vUv * 1. + uTime * 0.00003).rgb * 0.2 * noise2;\n\n  vec2 diffuseUv = mix(vec2(1. - vUv.x, vUv.y), vec2(1. - vUv.x, vUv.y) + noise.rg, uIsTlClouds);\n  vec4 color = texture2D(uDiffuse, diffuseUv);\n\n  // color.rgb += noise * 0.000001;\n  color.a *= mix(uAlpha, min(uAlpha, uAlphaDist), uIsTlClouds);\n  // color.a *= smoothstep(0.1, 0.4, (noise2.r + noise2.g * 0.01 + noise2.b * 0.01));\n  color.a *= .2;\n  // color.a = max(color.a, 0.15);\n\n  // color.rgb = mix(color.rgb, vec3(1., 0., 0.), uFirstRow);\n\n  float yFade = smoothstep(0.0, 0.2, vUv.y) * (1. - smoothstep(0.8, 1., vUv.y));\n  float xFade = smoothstep(0.0, 0.05, vUv.x) * 1. - smoothstep(0.95, 1., vUv.x);\n  float fade = xFade * yFade;\n  fade = smoothstep(0., .5, fade);\n  color.a *= fade;\n\n\n  gl_FragColor = color;\n  // gl_FragColor.rgb = vec3(smoothstep(0.1, 0.4, (noise2.r + noise2.g * 0.01 + noise2.b * 0.01) / 2.));\n  // gl_FragColor.rgb = vec3(noise2.gb * 1.2 * vUv.x,);\n  // gl_FragColor.rgb = vec3(vUv, 0.);\n  // gl_FragColor.a = max(gl_FragColor.a, 0.15);\n//   gl_FragColor.rgb = mix(vec3(uAlphaDist), vec3(1., 0., 0.), uFirstRow);\n  // gl_FragColor.r = uAlphaDist;\n  // gl_FragColor.a = 1.;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},70906:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute vec2 aTexCoord;\n\nvarying vec2 vUv;\nvarying float vDepth;\nuniform mat4 uMVP;\nuniform float uDist;\nuniform float uCamZ;\n\nvoid main(void) {\n  vec4 pos = vec4(aPosition, 1.0);\n\n  gl_Position = uMVP * pos;\n  vUv = aTexCoord;\n  \n  vDepth = smoothstep(130., 0., abs(uCamZ - gl_Position.z));\n  // vDepth =  1. - length(abs(uCamZ - gl_Position.z) / 150.);\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},93495:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\n\nuniform vec3 uColor;\nuniform float uFlicker;\nuniform float uTime;\nuniform float uAlpha;\n\nvarying float vOpacity;\nvarying float vRandom;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main(void){\n  float dist = distance(gl_PointCoord, vec2(0.5, 0.5));\n  dist = map(dist, 0., 0.5, 1., 0.);\n  dist = smoothstep(0., .8, dist);\n  dist *= vOpacity;\n  if (uFlicker > 0.) dist *= mix(1., sin(3.1415 * (uTime + vRandom) * 30.) + 1.5, uFlicker);\n  if (dist < 0.0) discard;\n  gl_FragColor = vec4(uColor, dist * uAlpha);\n}\n",o};o.toString=o,n.exports=o,o.onHmr=function(){}},78166:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute vec4 aSettings;\nattribute vec3 aAge;\n\nuniform mat4 uView;\nuniform float uTime;\nuniform mat4 uProjection;\nuniform sampler2D uNoise;\nuniform float uParticlesSpeed;\n\nvarying float vOpacity;\nvarying float vRandom;\n\nvoid main(void){\n  vec4 pos = vec4(aPosition, 1.0);\n  // pos.y += uTime * aSettings.z;\n  pos.y = mod(pos.y, aAge.y) - 5.0;\n\n  pos.z += uTime * aSettings.w;\n  pos.z = mod(pos.z, aAge.z) -100.0;\n\n  float life = ((pos.y+5.0) / aAge.y) * ((pos.z+100.0) / aAge.z);\n\n  pos.x += (texture2D(uNoise, vec2(pos.x, pos.y * .1)).r * 4. - 2.) * life * .5;\n  // pos.z += (texture2D(uNoise, vec2(pos.y * .1, pos.z)).r * 4. - 2.) * life * .5;\n\n  float smoothedScale = smoothstep(0., .2, life);\n  smoothedScale *= 1. - smoothstep(.2, 1., life);\n\n  gl_Position = uProjection * uView * pos;\n  gl_PointSize = 30. * aSettings.x * smoothedScale;\n\n  vOpacity = aSettings.y;\n  vRandom = aSettings.x;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},24825:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\n\nuniform vec3 uColor;\nuniform float uTime;\n\nvarying float vOpacity;\nvarying float vRandom;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main(void){\n  float dist = distance(gl_PointCoord, vec2(0.5, 0.5));\n  if (dist < 0.0) discard;\n  gl_FragColor = vec4(uColor, step(dist, 0.5) * vOpacity);\n}\n",o};o.toString=o,n.exports=o,o.onHmr=function(){}},28979:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute vec4 aSettings;\n\nuniform mat4 uProjection;\nuniform mat4 uView;\nuniform float uTime;\nuniform sampler2D uNoise;\nuniform float uScaleFactor;\nuniform vec3 uOffset;\n\nvarying float vOpacity;\nvarying float vRandom;\n\nvoid main(void){\n  vec4 pos = vec4(aPosition, 1.0);\n  pos.y += uTime * aSettings.w;\n  pos.y = mod(pos.y, aSettings.z);\n\n  float life = pos.y / aSettings.z;\n\n  pos.xyz += uOffset;\n\n  pos.x += (texture2D(uNoise, vec2(pos.x, pos.y * .1)).r * 4. - 2.) * life * .5;\n  pos.z += (texture2D(uNoise, vec2(pos.y * .1, pos.z)).r * 4. - 2.) * life * .5;\n\n  float smoothedScale = smoothstep(0., .2, life);\n  smoothedScale *= 1. - smoothstep(.2, 1., life);\n\n  gl_Position = uProjection * uView * pos;\n  gl_PointSize = 15. * aSettings.x * smoothedScale * 10. * uScaleFactor / gl_Position.w;\n\n  vOpacity = aSettings.y;\n  vRandom = aSettings.x;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},37968:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\n\nuniform vec3 uColor;\nuniform float uTime;\nuniform float uMinDistZ;\nuniform float uMaxDistZ;\nuniform float uMinDistX;\nuniform float uMaxDistX;\n\nvarying vec3 vWorldPos;\nvarying float vOpacity;\nvarying float vVisibility;\n\nvoid main(void){\n  float alpha = distance(gl_PointCoord, vec2(0.5, 0.5));\n  alpha = smoothstep(0.5, 0.3, alpha);\n  alpha *= vOpacity;\n  alpha *= smoothstep(uMaxDistZ, uMinDistZ, abs(vWorldPos.z));\n  alpha *= smoothstep(uMaxDistX, uMinDistX, abs(vWorldPos.x));\n  alpha *= vVisibility;\n\n  if (alpha < 0.0) discard;\n\n  gl_FragColor = vec4(uColor, alpha);\n}\n",o};o.toString=o,n.exports=o,o.onHmr=function(){}},19787:function(n){var o=function(n){var o="";return o+="attribute vec4 aPosScale;\nattribute vec4 aSettings;\n\nuniform mat4 uProjection;\nuniform mat4 uView;\nuniform vec2 uScale;\nuniform float uTime;\nuniform float uOffset;\nuniform float uMaxSize;\nuniform sampler2D uNoise;\n\nvarying vec3 vWorldPos;\nvarying float vOpacity;\nvarying float vVisibility;\n\nvoid main(void){\n  vec4 pos = vec4(aPosScale.xyz, 1.0);\n\n  pos.y += uTime * aSettings.w;\n  pos.y = mod(pos.y, aSettings.z);\n\n  float life = pos.y / aSettings.z;\n\n  pos.x += (texture2D(uNoise, vec2(pos.x, pos.y * .03)).r * 4. - 2.) * life * .5;\n  pos.z += (texture2D(uNoise, vec2(pos.y * .03, pos.z)).r * 4. - 2.) * life * .5;\n  pos.z += uOffset;\n\n  float lifeScale = smoothstep(0., .2, life);\n  lifeScale *= 1. - smoothstep(.2, 1., life);\n\n  float scaleSubtract = 1. - mix(uScale.x, uScale.y, aSettings.x);\n  float scale = max(aPosScale.w * lifeScale - scaleSubtract, 0.);\n\n  gl_Position = uProjection * uView * pos;\n  gl_PointSize = 30. * uMaxSize * scale / gl_Position.w;\n\n  vWorldPos = pos.xyz;\n\n  vOpacity = aSettings.y;\n  vVisibility = step(0.0001, scale);\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},28025:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\n\n#define PI 3.141592653\n#define PI_2 (PI * 2.)\n\nuniform float uTime;\nuniform float uAlpha;\nuniform float uScroll;\nuniform float uMinDist;\nuniform float uMaxDist;\nuniform float uQuadRatio;\nuniform float uSpeedProgress;\nuniform vec2 uRippleSeed;\nuniform vec2 uRippleSize;\nuniform vec4 uRipplePosition;\nuniform float uRippleTime;\nuniform sampler2D tNoise;\nuniform sampler2D tHeatmap;\n\nvarying float vWorldZ;\nvarying vec2 vTexCoord;\nvarying vec2 vHeatmapCoord;\n\nfloat ripples(vec2 coords, vec2 position, float seed, float size) {\n  vec2 center = vec2(position.x, (position.y - uScroll) * uQuadRatio);\n  float dist = distance(coords, center);\n\n  float angleOffset = seed * PI_2 + uRippleTime * 0.5;\n  float angle = mod(atan(coords.y - center.y, coords.x - center.x) + angleOffset, PI_2);\n  vec2 texCoords = vec2(\n    angle * 0.05,\n    dist * 10. - uRippleTime\n  );\n  vec4 tex = texture2D(tNoise, texCoords);\n  float pattern = mix(0., tex.r, smoothstep(0., 0.2, angle) - smoothstep(PI_2 - 0.2, PI_2, angle));\n\n  float limit = min(\n    // ripple outer limit\n    smoothstep(0.05, 0.14, dist)\n    // ripple grow\n    + step(0.14 * size, dist)\n    // ripple disappear\n    + (1. - size)\n    , 1.);\n\n  float stepVal = 0.55 + 0.45 * limit;\n  return smoothstep(stepVal - 0.02, stepVal + 0.02, pattern);\n}\n\nvoid main(void){\n  // --NOISE--\n  vec4 noiseTemp = texture2D(tNoise, vec2(vTexCoord.x * 15. + uTime * 0.01, (vTexCoord.y + uScroll) * uQuadRatio) + uTime * 0.1);\n  vec4 noise = texture2D(tNoise, vec2(vTexCoord.x + noiseTemp.r * 0.08, (vTexCoord.y + uScroll) * uQuadRatio + uTime * 0.04));\n  float xNoise = vTexCoord.x + (noise.r * 0.03 - 0.015) * (1. - uSpeedProgress * 0.8);\n\n  // --STREAMS--\n  vec4 heatmap = texture2D(tHeatmap, vHeatmapCoord);\n  float offset = heatmap.g * heatmap.b;\n  float direction = (texture2D(\n    tHeatmap,\n    vec2(vHeatmapCoord.x + offset, vHeatmapCoord.y)\n  ).g - heatmap.g * 0.5) * 2.;\n\n  float streamX = xNoise + offset * direction;\n  float streamOffset = texture2D(tNoise, vec2(streamX, 0.)).r;\n  float streamCoords = fract(streamX * (7. + streamOffset * 7.));\n  float streamSize = mix(0.05, 0., uSpeedProgress * 0.5);\n  float streams = smoothstep(0.45 - streamSize, 0.55 - streamSize, streamCoords) - smoothstep(0.55 + streamSize, 0.65 + streamSize, streamCoords);\n\n  vec2 alphaCoords = vec2(vTexCoord.x * 1.2 + noise.g * 0.02 - 0.01, (vTexCoord.y + uScroll) * 0.1 * uQuadRatio + noise.b * 0.02);\n  float alphaNoise = texture2D(tNoise, alphaCoords).g;\n  float alphaRock = heatmap.g * 0.5;\n  float stepVal = 0.55 + noise.r * 0.1 - 0.05;\n  float streamAlpha = smoothstep(stepVal - 0.15, stepVal + 0.15, alphaNoise + alphaRock) * 0.9;\n\n  // --ROCKS--\n  vec2 heatmapNoiseCoords = vec2(vHeatmapCoord.x + noise.g * 0.02 - 0.01, vHeatmapCoord.y + noise.b * 0.02 - 0.01);\n  float rock = smoothstep(0.5, 0.6, texture2D(tHeatmap, heatmapNoiseCoords).g);\n\n  // --RIPPLES--\n  vec2 rippleCoords = vec2(vTexCoord.x + (noise.r * 0.02 - 0.01), vTexCoord.y * uQuadRatio);\n  float startRockRipples = ripples(rippleCoords, uRipplePosition.xy, uRippleSeed.x, uRippleSize.x);\n  float endRockRipples = ripples(rippleCoords, uRipplePosition.zw, uRippleSeed.y, uRippleSize.y);\n  float rockRipples = max(startRockRipples, endRockRipples);\n\n  // --FOG--\n  float fogVal = smoothstep(uMaxDist, uMinDist, abs(vWorldZ));\n  float fogAlpha = max(fogVal - smoothstep(1., 0.5, fogVal) * heatmap.r, 0.);\n\n  // --RESULT--\n  float riverPattern = abs(max(streams, rock) * streamAlpha - rockRipples);\n  float riverAlpha = (smoothstep(0.2, 0.3, xNoise) - smoothstep(0.7, 0.8, xNoise));\n  float alpha = uAlpha * fogAlpha;\n\n  gl_FragColor = vec4(vec3(0.85, 1., 1.), riverPattern * riverAlpha * alpha);\n}\n",o};o.toString=o,n.exports=o,o.onHmr=function(){}},73042:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute vec2 aTexCoord;\n\nuniform mat4 uVP;\nuniform mat4 uWorldMatrix;\nuniform vec2 uHeatmapScale;\n\nvarying float vWorldZ;\nvarying vec2 vTexCoord;\nvarying vec2 vHeatmapCoord;\n\nvoid main( void ){\n  vec4 worldPos = uWorldMatrix * vec4(aPosition, 1.0);\n  gl_Position = uVP * worldPos;\n\n  vTexCoord = aTexCoord;\n  vWorldZ = worldPos.z;\n  vHeatmapCoord = worldPos.xz * uHeatmapScale + vec2(0.5);\n}\n",o};o.toString=o,n.exports=o,o.onHmr=function(){}},7588:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\n#define PI 3.141592653589793\n#define HALF_PI 1.5707963267948966\n\nvarying vec2 vParams;\nvarying float vAngle;\n\nuniform float uGlobalAlpha;\nuniform float uTime;\nuniform sampler2D uNoise;\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nfloat quadraticOut(float t) {\n  return -t * (t - 2.0);\n}\n\nfloat sineIn(float t) {\n  return sin((t - 1.0) * HALF_PI) + 1.0;\n}\n\nfloat greyscale(vec3 col) {\n  float grey = dot(col, vec3(0.299, 0.587, 0.114));\n  return grey;\n}\n\n\nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sat(float value) {\n  return clamp(value, 0., 1.);\n}\n\nvec3 SHAPE_START_COLOR = vec3(13. / 255., 20. / 255., 81. / 255.);\nvec3 SHAPE_END_COLOR = vec3(190. / 255., 240. / 255., 245. / 255.);\n\nvoid main() {\n  float segLength = vParams.y;\n  float progress = clamp(vParams.x, 0., 1. + segLength);\n\n  vec2 noise = texture2D(uNoise, gl_PointCoord * .1 + uTime * 0.0001).rg;\n\n  vec2 uv = vec2(gl_PointCoord.x, 1. - gl_PointCoord.y);\n  uv -= 0.5;\n  uv = rotate(uv, vAngle);\n  uv += 0.5;\n  uv *= 1.4;\n  vec2 plotUv = uv;\n\n  plotUv.x = pow(plotUv.x, 2.);\n  plotUv.y -= 0.05;\n\n  float plotUvRatio = plotUv.y / plotUv.x;\n\n\n  float end = 0. + progress;\n  float start = 0. - segLength + sineIn(progress);\n  float progressMask = smoothstep(start, end, uv.x) - step(end, uv.x);\n  float colorGradient = smoothstep(start, end + progress, uv.x);\n  float invtProgressMask = 1. - progressMask;\n\n  float path = abs(plotUv.y - plotUv.x);\n  path = step(sat(.01 - invtProgressMask * 0.01), path);\n\n  float shape = 1. - path;\n  shape *= progressMask;\n\n\n\n  vec2 tipPos = vec2(0.0, 0.05);\n  float tipCircle = distance(uv, vec2(tipPos.x + progress, tipPos.y + pow(progress, 2.)));\n  // tipCircle += noise.r * .1;\n  tipCircle = 1. - tipCircle;\n  \n  float coreTip = smoothstep(0.975, 1.0 - 0.05 * (noise.g * 0.1), tipCircle);\n  coreTip = map(coreTip, 0., 1., 0., 0.1);\n  float secondTip = smoothstep(0.89, 1., tipCircle);\n  // secondTip *= 0.8;\n  secondTip = min(secondTip, 0.9);\n  float tipRing = smoothstep(0.85, 1., tipCircle);\n  tipRing -= smoothstep(0.86, 1., tipCircle);\n  tipRing *= 3.;\n  tipRing *= 1. - 0.1 * (noise.r * 2.);\n\n  float tip = (secondTip + coreTip);\n  tip = mix(tipRing * (1. - noise.r * .4), tip, tip);\n\n  vec3 tipColor = mix(vec3(0.), vec3(1.), tip);\n  tipColor = mix(tipColor, vec3(128. / 255., 0., 255. / 255.), tipRing);\n\n  vec3 color = mix(SHAPE_START_COLOR, SHAPE_END_COLOR, quadraticOut(colorGradient * (1. - path)));\n  color *= vec3(smoothstep(0., 0.1, shape)) * 1.;\n  color = blendScreen(color, tipColor, sat(tip * 2.5));\n  // color = tipColor;\n\n  float progressFade = smoothstep(0.05, 0.5, progress) - smoothstep(0.8, 1., progress);\n  float alpha = greyscale(color);\n  alpha *= progressFade;\n\n  color = mix(vec3(1.), color, alpha * 1.2);\n\n  gl_FragColor = vec4(color, alpha);\n  gl_FragColor.a *= 0.4;\n  gl_FragColor.a *= progressFade;\n  gl_FragColor.a = min(gl_FragColor.a, uGlobalAlpha);\n  // gl_FragColor.rgb = vec3(noise.r);\n  // gl_FragColor.a = 1.;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},18270:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute vec2 aParams;\nattribute float aRotation;\n\nuniform mat4 uVP;\nuniform mat4 uWorldMatrix;\n\nvarying vec2 vParams;\nvarying float vAngle;\n\nvoid main() {\n  vec4 pos = uVP * uWorldMatrix * vec4(aPosition, 1.0);\n\n  gl_Position = pos;\n  gl_PointSize = 2000.;\n\n  vParams = aParams;\n  vAngle = aRotation;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},54713:function(n){var o=function(n){var o="";return o+="precision mediump float;\n\nvarying lowp vec3 vRaydir;\nuniform samplerCube tCubemap;\n\n\n\nvoid main( void ){\n\n  vec3 wDir = normalize( vRaydir );\n  gl_FragColor = textureCube( tCubemap, wDir );\n\n\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},35702:function(n){var o=function(n){var o="";return o+="precision lowp float;\n\nattribute vec2 aPosition;\n\nuniform mat4 uUnproject;\n\nvarying lowp vec3 vRaydir;\n\nvoid main( void ){\n  vec4 pos = vec4( aPosition, .5, 1.0 );\n  vRaydir = normalize( (uUnproject * pos).xyz );\n  gl_Position = pos;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},92327:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\nvarying float vOpacity;\nvarying float vOffset;\nvarying float vSize;\n\nuniform sampler2D uNoise;\nuniform float uTime;\nuniform float uGlobalAlpha;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main() {\n  float noise = texture2D(uNoise, gl_PointCoord * .5 + vOffset).r;\n  float sizeFact = map(noise, 40., 90., 0., 1.);\n\n  float alphaTime = mod(uTime * 0.0001, 1.);\n  float alphaNoise = texture2D(uNoise,  vec2(vOffset * 10. + alphaTime, vOffset + 0.5 + alphaTime)).g;\n\n  float dist = distance(gl_PointCoord, vec2(0.5));\n  dist = 1. - dist;\n  // dist += noise * 0.0000001;\n  float shape = min(0.8, smoothstep(0.45, 1. + noise * 0.1, dist));\n  shape += min(0.2, smoothstep(clamp(0.3 + noise * 0.5, 0.2, .7), 1., dist));\n\n  float alpha = 0.5 * vOpacity * alphaNoise;\n  alpha *= shape;\n  alpha = min(alpha, uGlobalAlpha);\n  // alpha = 1.;\n\n  gl_FragColor = vec4(vec3(shape), alpha);\n  // gl_FragColor = vec4(atan(gl_PointCoord.x - 0.5, gl_PointCoord.y - 0.5) / 3.1456, 0., 0., 1.);\n  // gl_FragColor = vec4(vec3(alphaNoise), 1.);\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},21705:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute float aAlpha;\nattribute float aSize;\nattribute vec4 aMovement;\nuniform mat4 uVP;\nuniform mat4 uWorldMatrix;\nvarying float vOpacity;\nvarying float vOffset;\nvarying float vSize;\n\nvoid main() {\n  vec4 pos = uVP * uWorldMatrix * vec4(aPosition, 1.0);\n\n  gl_Position = pos;\n  gl_PointSize = (90. - aSize) / gl_Position.w;\n\n  vOpacity = aAlpha;\n  vOffset = aMovement.x;\n  vSize = aSize;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},94531:function(n){var o=function(n){var o="";return o+="precision "+n.highp+" float;\n\nuniform vec3 uTopColor;\nuniform vec3 uBottomColor;\nuniform vec2 uViewportSize;\n\nvarying vec2 vUv;\nvarying vec4 vPosition;\n\nvoid main(void){\n  vec3 color = mix(uBottomColor, uTopColor, gl_FragCoord.y / uViewportSize.y / (uViewportSize.x / uViewportSize.y));\n\n  float dist = distance(vUv, vec2(.5));\n  dist = smoothstep(0.15, 0.3, dist);\n\n  gl_FragColor = vec4(color, dist);\n}\n",o};o.toString=o,n.exports=o,o.onHmr=function(){}},81561:function(n){var o=function(n){var o="";return o+="attribute vec3 aPosition;\nattribute vec2 aTexCoord;\n\nvarying vec4 vPosition;\nvarying vec2 vUv;\n\nuniform mat4 uMVP;\n\nvoid main(void){\n  vec4 pos = vec4(aPosition, 1.0);\n\n  gl_Position = uMVP * pos;\n  \n  vPosition = gl_Position;\n  vUv = aTexCoord;\n}",o};o.toString=o,n.exports=o,o.onHmr=function(){}},76879:function(n,o,e){"use strict";e.d(o,{Z:function(){return r},d:function(){return i}});var t=e(29845);function r(n){return n}function i(n,o,e,r,i){return new t.Z(n,o(i),e(i),r)}},31236:function(n,o,e){"use strict";e.r(o),e.d(o,{ProgramsLib:function(){return v},default:function(){return c}});var t=e(55411),r=e(29845),i=e(76879);const a=e(55100),l=[];function s(n){let o=l.find((o=>o.id===n));return void 0===o&&(o={id:n,vert:null,frag:null,vertModuleId:null,fragModuleId:null},l.push(o)),o}a.keys().forEach((n=>{const o=n.substring(2,n.length),e=o.split("/")[0],t=s(e);o.endsWith("frag")?(t.fragModuleId=n,t.frag=a(n)):(t.vertModuleId=n,t.vert=a(n))}));for(const f of l){if(null===f.vert)throw`Program ${f.id} missing vertex shader`;if(null===f.frag)throw`Program ${f.id} missing fragment shader`}class v{constructor(n){this.gl=n,this.highp="lowp",this.mediump="lowp",this.capabilities=(0,t.Z)(n),this.mediump=this.capabilities.hasMediumpPrecision?"mediump":"lowp",this.highp=this.capabilities.hasHighpPrecision?"highp":this.mediump,this.version="#version "+(this.capabilities.isWebgl2?"300 es":"100"),this._programs=new Map;for(const o of l){const e=new r.Z(n,o.vert(this),o.frag(this));this._programs.set(o.id,e)}}create(n,o,e){return(0,i.d)(this.gl,n,o,e,this)}get(n){if(!this._programs.has(n))throw`Program "${n}" not found`;return this._programs.get(n)}}const u=new WeakMap;function c(n){let o=u.get(n);return o||(o=new v(n),u.set(n,o)),o}},55100:function(n,o,e){var t={"./archives/shader.frag":69115,"./archives/shader.vert":85164,"./archivesManager/shader.frag":54895,"./archivesManager/shader.vert":10466,"./background/shader.frag":23131,"./background/shader.vert":28546,"./blit/shader.frag":8811,"./blit/shader.vert":30610,"./brush/shader.frag":29491,"./brush/shader.vert":1587,"./brushRender/shader.frag":39483,"./brushRender/shader.vert":33431,"./clouds-particles/shader.frag":70071,"./clouds-particles/shader.vert":25806,"./conclusion-background/shader.frag":45695,"./conclusion-background/shader.vert":89606,"./conclusion-clouds/shader.frag":5229,"./conclusion-clouds/shader.vert":97062,"./conclusion-dots/shader.frag":97911,"./conclusion-dots/shader.vert":51981,"./dots/shader.frag":16802,"./dots/shader.vert":78755,"./intro-background/shader.frag":34779,"./intro-background/shader.vert":99435,"./intro-clouds/shader.frag":41830,"./intro-clouds/shader.vert":70906,"./particles-field/shader.frag":93495,"./particles-field/shader.vert":78166,"./pond-energy/shader.frag":24825,"./pond-energy/shader.vert":28979,"./river-particles/shader.frag":37968,"./river-particles/shader.vert":19787,"./river/shader.frag":28025,"./river/shader.vert":73042,"./shooting-stars/shader.frag":7588,"./shooting-stars/shader.vert":18270,"./skybox/shader.frag":54713,"./skybox/shader.vert":35702,"./stars/shader.frag":92327,"./stars/shader.vert":21705,"./water-surface/shader.frag":94531,"./water-surface/shader.vert":81561};function r(n){var o=i(n);return e(o)}function i(n){if(!e.o(t,n)){var o=new Error("Cannot find module '"+n+"'");throw o.code="MODULE_NOT_FOUND",o}return t[n]}r.keys=function(){return Object.keys(t)},r.resolve=i,n.exports=r,r.id=55100}}]);
//# sourceMappingURL=1236.156d84e3.js.map