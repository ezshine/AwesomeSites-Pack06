import{h as C,au as D,r as E,V as T,av as R,__tla as O}from"./BpGrYj0z.js";let x,X=Promise.all([(()=>{try{return O}catch{}})()]).then(async()=>{function S(i,t){if(!i)throw new Error(t)}function l(i,t){return typeof i<"u"&&i!==null?i:t}const w=class A{constructor(t={}){this._listeners=[],this._currentAnimationStep=0,this._currentTime=0,this._springTime=0,this._currentValue=0,this._currentVelocity=0,this._isAnimating=!1,this._oscillationVelocityPairs=[],this._config={fromValue:l(t.fromValue,0),toValue:l(t.toValue,1),stiffness:l(t.stiffness,100),damping:l(t.damping,10),mass:l(t.mass,1),initialVelocity:l(t.initialVelocity,0),overshootClamping:l(t.overshootClamping,!1),allowsOverdamping:l(t.allowsOverdamping,!1),restVelocityThreshold:l(t.restVelocityThreshold,.001),restDisplacementThreshold:l(t.restDisplacementThreshold,1e-4),maxVelocity:l(t.maxVelocity,1/0)},this._currentValue=this._config.fromValue,this._currentVelocity=this._config.initialVelocity}start(){const{fromValue:t,toValue:e,initialVelocity:s}=this._config;return(t!==e||s!==0)&&(this._reset(),this._isAnimating=!0),this}stop(){return this._isAnimating?(this._isAnimating=!1,this._notifyListeners("onStop"),this._currentAnimationStep&&(cancelAnimationFrame(this._currentAnimationStep),this._currentAnimationStep=0),this):this}get currentValue(){return this._currentValue}get currentVelocity(){return this._currentVelocity}get isAtRest(){return this._isSpringAtRest()}get isAnimating(){return this._isAnimating}updateConfig(t){this._advanceSpringToTime(Date.now());const e={fromValue:this._currentValue,initialVelocity:this._currentVelocity};return this._config={...this._config,...e,...t},this._reset(),this}onStart(t){return this._listeners.push({onStart:t}),this}onUpdate(t){return this._listeners.push({onUpdate:t}),this}onStop(t){return this._listeners.push({onStop:t}),this}removeListener(t){return this._listeners=this._listeners.reduce((e,s)=>(Object.values(s).indexOf(t)!==-1||e.push(s),e),[]),this}removeAllListeners(){return this._listeners=[],this}_reset(){this._currentTime=Date.now(),this._springTime=0,this._currentValue=this._config.fromValue,this._currentVelocity=this._config.initialVelocity}_notifyListeners(t){this._listeners.forEach(e=>{const s=e[t];typeof s=="function"&&s(this)})}_step(t){this._advanceSpringToTime(t,!0)}_advanceSpringToTime(t,e=!1){if(!this._isAnimating)return;let s=t-this._currentTime;s>A.MAX_DELTA_TIME_MS&&(s=A.MAX_DELTA_TIME_MS),this._springTime+=s;const f=this._config.damping,p=this._config.mass,d=this._config.stiffness,L=this._config.fromValue,m=this._config.toValue,g=-this._config.initialVelocity,H=this._config.maxVelocity;S(p>0,"Mass value must be greater than 0"),S(d>0,"Stiffness value must be greater than 0");let n=f/(2*Math.sqrt(d*p));const o=Math.sqrt(d/p)/1e3,u=o*Math.sqrt(1-n*n),h=o*Math.sqrt(n*n-1),a=m-L;n>1&&!this._config.allowsOverdamping&&(n=1);let V=0,_=0;const r=this._springTime;if(n<1){const c=Math.exp(-n*o*r);V=m-c*((g+n*o*a)/u*Math.sin(u*r)+a*Math.cos(u*r)),_=n*o*c*(Math.sin(u*r)*(g+n*o*a)/u+a*Math.cos(u*r))-c*(Math.cos(u*r)*(g+n*o*a)-u*a*Math.sin(u*r))}else if(n===1){const c=Math.exp(-o*r);V=m-c*(a+(g+o*a)*r),_=c*(g*(r*o-1)+r*a*(o*o))}else{const c=Math.exp(-n*o*r);V=m-c*((g+n*o*a)*Math.sinh(h*r)+h*a*Math.cosh(h*r))/h,_=c*n*o*(Math.sinh(h*r)*(g+n*o*a)+a*h*Math.cosh(h*r))/h-c*(h*Math.cosh(h*r)*(g+n*o*a)+h*h*a*Math.sinh(h*r))/h}if(_=Math.max(-H,Math.min(H,_)),this._currentTime=t,this._currentValue=V,this._currentVelocity=_,!!e&&(this._notifyListeners("onUpdate"),!!this._isAnimating&&(this._isSpringOvershooting()||this._isSpringAtRest()))){d!==0&&(this._currentValue=m,this._currentVelocity=0,this._notifyListeners("onUpdate")),this.stop();return}}_isSpringOvershooting(){const{stiffness:t,fromValue:e,toValue:s,overshootClamping:f}=this._config;let p=!1;return f&&t!==0&&(e<s?p=this._currentValue>s:p=this._currentValue<s),p}_isSpringAtRest(){const{stiffness:t,toValue:e,restDisplacementThreshold:s,restVelocityThreshold:f}=this._config,p=Math.abs(this._currentVelocity)<=f;return t!==0&&Math.abs(e-this._currentValue)<=s&&p}};w.MAX_DELTA_TIME_MS=1/60*1e3*4;let y=w;const W={stiffness:500,damping:17},v=new T,P=new T,M=new C(new D(.03),new E({transparent:!0}));x=class{constructor(i,t={}){this.options={...W,...t};const e=i.clone();i.parent.add(e),e.add(i),this.target=i,this.targetHelper=M.clone(),t.scene&&t.scene.add(this.targetHelper),this.currentHelper=M.clone(),t.scene&&t.scene.add(this.currentHelper),this.currentHelper.add(M.clone()),this.currentHelper.children[0].position.y=-.1,this._isFirstStep=!0;const s={stiffness:this.options.stiffness,damping:this.options.damping};this.springX=new y({fromValue:0,toValue:0,...s}),this.springY=new y({fromValue:0,toValue:0,...s}),this.springZ=new y({fromValue:0,toValue:0,...s}),this.originPosition=i.position.clone(),this.originRotation=i.rotation.clone(),this.oldBoneWorldPosition=new T,this.oldBoneWorldRotation=new R,this.target.getWorldPosition(this.oldBoneWorldPosition),this.target.getWorldQuaternion(this.oldBoneWorldRotation),this.restLength=this.target.parent.position.length(),this.reset()}reset(){this._isFirstStep=!0,this.target.position.copy(this.originPosition),this.target.rotation.copy(this.originRotation),this.target.updateMatrixWorld(!0,!1),this.target.getWorldPosition(this.oldBoneWorldPosition)}dispose(){this.reset();const i=this.target.parent,t=i.parent;t.remove(i),t.add(this.target)}update(i=null){if(!i)if(this.ms){const e=performance.now();i=e-this.ms,i/=1e3,this.ms=e}else this.ms=performance.now(),i=16/1e3;let t=1;if(i=Math.min(i,100),i>.01&&(t=2),i>=100&&(t=25),!(i<.006))for(let e=0;e<t;e++)this.step(.0085*100)}step(i){this.target.parent.updateMatrixWorld(!0,!1),this.targetHelper.position.copy(this.originPosition),this.target.parent.localToWorld(this.targetHelper.position),this._isFirstStep&&(this._isFirstStep=!1,this.springX.updateConfig({fromValue:this.targetHelper.position.x}),this.springY.updateConfig({fromValue:this.targetHelper.position.y}),this.springZ.updateConfig({fromValue:this.targetHelper.position.z})),this.springX.updateConfig({toValue:this.targetHelper.position.x}).start(),this.springY.updateConfig({toValue:this.targetHelper.position.y}).start(),this.springZ.updateConfig({toValue:this.targetHelper.position.z}).start();const t=Date.now();this.springX._step(t),this.springY._step(t),this.springZ._step(t),this.target.position.set(this.springX.currentValue,this.springY.currentValue,this.springZ.currentValue),this.target.parent.worldToLocal(this.target.position),this.oldBoneWorldPosition.copy(v);const e=this.target.parent.getWorldPosition(P);this.currentHelper.position.copy(v),this.currentHelper.updateMatrixWorld(!0,!1),this.currentHelper.lookAt(e);const s=this.target.position.clone();s.normalize(),this.target.up.set(0,1,0),this.target.quaternion.setFromUnitVectors(this.target.up,s),this.target.position.set(0,0,0),this.target.updateMatrix()}}});export{x as O,X as __tla};
